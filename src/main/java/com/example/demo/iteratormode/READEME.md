#迭代器模式	--	属于适应性设计模式为了符合之前的某些标准

在面向对象的软件设计中，我们经常会遇到一类集合对象，这类集合对象的内部结构可能有着各种各样的实现，但是归结起来，无非有两点是需要我们去关心的：一是集合内部的数据存储结构，二是遍历集合内部的数据。面向对象设计原则中有一条是类的单一职责原则，所以我们要尽可能的去分解这些职责，用不同的类去承担不同的职责。Iterator模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据。

1.通俗的来说，就是，别人可能要用到我们的容器元素，但是我只想让他用元素，不想让他知道容器是怎么样的。也就是最基本的，访问各个元素而不暴露容器内部细节。
2.我们有可能以一种以上的方式遍历容器元素
3.同时对容器元素进行多次遍历。因为迭代器会保存当前的遍历状态，所以可以通过迭代器模式来达到这种需求。

该模式所拥有的角色有以下四种
(1) 迭代器角色(Iterator)：迭代器角色负责定义访问和遍历元素的接口。
(2) 具体迭代器角色(Concrete Iterator)：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。
(3) 容器角色(Container)：容器角色负责提供创建具体迭代器角色的接口。
(4) 具体容器角色(Concrete Container)：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。

优点：
1.1更好的封装性：抽出变化的部分，并封装，抽出公共的能力。且支持使用不同的方式来遍历同一个角色。且可以对同一个角色同时进行遍历，因为遍历的状态是保存在各个迭代器中的。
1.2需要进行变化的部分在于，集合所拥有的数据结构是多变得我们不能控制，比如现在使用的数据，而以后可能会使用链表等结构，这样的话for循环等迭代不适用，而且这种能力是所有集合都需要的，所以有必要抽出一个公共的接口来进行控制。即《inteface》:Iterator
1.3而且该迭代能力集合框架一般都具备，而集合框架已经对数据的增删改查进行了封装，在封装这种具有保存迭代状态的操作容易造成紊乱，这样就简化了聚合的接口，而且这样也符合接口最小化的原则。
1.4新增新的聚合类和迭代类都十分方便，且更改原有聚合类的数据结构时，只更改或新增对应的迭代类即可，不必对集合类做太多的了解。符合开闭原则

缺点：
2.1由1.1可知。这种变化可能会在后期修改增加多种迭代的实现从而造成系统的复杂性


需要注意的是：
1.迭代器角色(Iterator)中的next()方法的全称应该为returnCurrentElementAndAdvanceToNextPosition(),即返回当前的元素并将指针指向下一个元素.
2.而hasNext()的方法就只是确定接下来是否可以调用next方法
3.多个Iterator:"将遍历功能置于Aggregate角色之外",将变化的部分抽出,符合开闭原则,符合接口最小原则
根据依赖倒置原则,可以抽出一个统一的迭代接口,根据这个特征一个具体容器角色(Concrete Container)可以编写多个具体迭代器角色(Concrete Iterator)
有后往前遍历的,有可以双向遍历的即有next()和previous()方法的,指定下标可以进行"跳跃式"遍历的





